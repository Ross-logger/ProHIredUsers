image: docker:latest

services:
  - docker:dind  # Docker-in-Docker to run containers in the CI environment

stages:
  - build
  - test
  - deploy

before_script:
  # Load environment variables from the .env file
  - echo "$ENV_FILE" > .env
  - export $(grep -v '^#' .env | xargs)

# Build the Docker images using docker-compose
build-job:
  stage: build
  script:
    - echo "Building Docker images with docker-compose..."
    - docker-compose build  # Build all services defined in docker-compose.yml
  only:
    - branches  # Run on all branches

# Run tests using the built Docker images
test-job:
  stage: test
  script:
    - echo "Running tests using docker-compose..."
    - docker-compose up -d  # Start the services in detached mode
    - docker-compose exec users_service pytest --junitxml=report.xml  # Run pytest inside the users_service container
  artifacts:
    reports:
      junit: report.xml  # Save the test report as an artifact
  dependencies:
    - build-job  # Ensure the test job runs only after the image is built

# Deploy the application using docker-compose
#deploy-job:
#  stage: deploy
#  script:
#    - echo "Deploying the application..."
#    - docker-compose up -d --build  # Rebuild and start the services
#  only:
#    - master  # Run only on the master branch
#  environment:
#    name: production
#    url: http://localhost  # Update with your actual production URL if needed